import { isNil } from 'lodash';
import { PropDef } from '@storybook/components';
import { ReactNode } from 'react';
import { ExtractedProp } from '../../lib2/extractDocgenProps';
import { ExtractedJsDocParam } from '../../lib2/jsdocParser';
import { createPropText } from '../../lib2/createComponents';

const MAX_CAPTION_LENGTH = 35;

enum PropType {
  CUSTOM = 'custom',
  FUNC = 'func',
  SHAPE = 'shape',
  INSTANCEOF = 'instanceOf',
  OBJECTOF = 'objectOf',
  UNION = 'union',
  ENUM = 'enum',
  ARRAYOF = 'arrayOf',
}

interface Type {
  name: string;
  value?: any;
  computed?: boolean;
  raw?: string;
  description?: string;
}

// TODO: Might delete and use any
interface EnumValue {
  value: string;
  computed: boolean;
}

enum InspectionType {
  OBJECT = 'object',
  ARRAY = 'array',
  FUNCTION = 'func',
  ELEMENT = 'element',
  STRING = 'string',
}

interface InspectionResult {
  guessedType: InspectionType;
}

interface TypeDef {
  name: string;
  caption: string;
  value: string;
  guessedType?: InspectionType;
}

function inspectTypeValue(value: string): InspectionResult {
  const trimmedValue = value.trimLeft();
  let type = InspectionType.STRING;

  if (trimmedValue.startsWith('{')) {
    type = InspectionType.OBJECT;
  } else if (trimmedValue.startsWith('[')) {
    type = InspectionType.ARRAY;
  } else if (trimmedValue.startsWith('()') || trimmedValue.startsWith('function')) {
    type = mightBeComponent(trimmedValue) ? InspectionType.ELEMENT : InspectionType.FUNCTION;
  } else if (trimmedValue.startsWith('class') && mightBeComponent(trimmedValue)) {
    type = InspectionType.ELEMENT;
  }

  return {
    guessedType: type,
  };
}

function mightBeComponent(value: string): boolean {
  return value.includes('React') || value.includes('Component') || value.includes('render');
}

function prettifyObject(value: string): string {
  const cleanedValue = value.replace(/PropTypes./g, '').replace(/.isRequired/g, '');

  // try {
  //   // Trying to re-build the value to provide a better formatting.
  //   // This is considered safe since this is the code generated by docgen that is evaluated.
  //   // eslint-disable-next-line no-eval
  //   const object = eval(`(${cleanedValue})`);

  //   // TODO: Use import objectToString from 'javascript-stringify'.
  //   return JSON.stringify(object, null, 2);
  // } catch (e) {
  //   // do nothing.
  // }

  return cleanedValue;
}

function createTypeDef({
  name,
  caption,
  value,
  guessedType,
}: {
  name: string;
  caption: string;
  value?: string;
  guessedType?: InspectionType;
}): TypeDef {
  return {
    name,
    caption,
    value: !isNil(value) ? value : caption,
    guessedType,
  };
}

// TODO: Fix "oneOfComplexShapes"
function generateComputedValue(typeName: string, value: string): TypeDef {
  const { guessedType } = inspectTypeValue(value);

  return createTypeDef({
    name: typeName,
    caption: guessedType.toString(),
    value: guessedType === InspectionType.OBJECT ? prettifyObject(value) : value,
    guessedType,
  });
}

function generateCustom({ raw }: Type): TypeDef {
  if (!isNil(raw)) {
    const { guessedType } = inspectTypeValue(raw);

    return createTypeDef({
      name: PropType.CUSTOM,
      caption: 'custom',
      value: guessedType === InspectionType.OBJECT ? prettifyObject(raw) : raw,
      guessedType,
    });
  }

  return createTypeDef({ name: PropType.CUSTOM, caption: 'custom' });
}

function generateFuncSignature(
  { jsDocTags }: ExtractedProp,
  hasParams: boolean,
  hasReturns: boolean
): string {
  const funcParts = [];

  if (hasParams) {
    const funcParams = jsDocTags.params.map((x: ExtractedJsDocParam) => {
      const prettyName = x.getPrettyName();
      const typeName = x.getTypeName();

      if (!isNil(typeName)) {
        return `${prettyName}: ${typeName}`;
      }

      return prettyName;
    });

    funcParts.push(`(${funcParams.join(', ')})`);
  } else {
    funcParts.push('()');
  }

  if (hasReturns) {
    funcParts.push(`=> ${jsDocTags.returns.getTypeName()}`);
  }

  return funcParts.join(' ');
}

function generateFunc(extractedProp: ExtractedProp): TypeDef {
  const { jsDocTags } = extractedProp;

  if (!isNil(jsDocTags)) {
    const hasParams = !isNil(jsDocTags.params);
    const hasReturns = !isNil(jsDocTags.returns);

    if (hasParams || hasReturns) {
      return createTypeDef({
        name: PropType.FUNC,
        caption: 'func',
        value: generateFuncSignature(extractedProp, hasParams, hasReturns),
      });
    }
  }

  return createTypeDef({ name: PropType.FUNC, caption: 'func' });
}

// TODO: do somekind of eval / stringify to format.
function generateShape(type: Type, extractedProp: ExtractedProp): TypeDef {
  const fields = Object.keys(type.value)
    .map((key: string) => `${key}: ${generateType(type.value[key], extractedProp).value}`)
    .join(', ');

  return createTypeDef({ name: PropType.SHAPE, caption: 'object', value: `{ ${fields} }` });
}

function generateObjectOf(type: Type, extractedProp: ExtractedProp): TypeDef {
  const format = (of: string) => `objectOf(${of})`;

  // eslint-disable-next-line prefer-const
  let { name, caption, value, guessedType } = generateType(type.value, extractedProp);

  if (name === PropType.CUSTOM) {
    if (!isNil(guessedType)) {
      switch (guessedType) {
        case InspectionType.STRING:
        case InspectionType.OBJECT:
          // Display the name of the object var if it's short.
          if (value.length <= MAX_CAPTION_LENGTH) {
            caption = value;
          }
          break;
        default:
          caption = guessedType.toString();
      }
    }
  } else if (name === PropType.SHAPE) {
    if (value.length <= MAX_CAPTION_LENGTH) {
      caption = value;
    }
  }

  return createTypeDef({
    name: PropType.OBJECTOF,
    caption: format(caption),
    value: format(value),
  });
}

function generateUnion(type: Type, extractedProp: ExtractedProp): TypeDef {
  if (Array.isArray(type.value)) {
    const values = type.value.reduce(
      (acc: any, v: any) => {
        const { caption, value } = generateType(v, extractedProp);

        acc.caption.push(caption);
        acc.value.push(value);

        return acc;
      },
      { caption: [], value: [] }
    );

    return createTypeDef({
      name: PropType.UNION,
      caption: values.caption.join(' | '),
      value: values.value.join(' | '),
    });
  }

  return createTypeDef({ name: PropType.UNION, caption: type.value });
}

function generateEnumValue({ value, computed }: EnumValue): TypeDef {
  return computed
    ? generateComputedValue('enumvalue', value)
    : createTypeDef({ name: 'enumvalue', caption: value });
}

function generateEnum(type: Type): TypeDef {
  if (Array.isArray(type.value)) {
    const values = type.value.reduce(
      (acc: any, v: EnumValue) => {
        const { caption, value } = generateEnumValue(v);

        acc.caption.push(caption);
        acc.value.push(value);

        return acc;
      },
      { caption: [], value: [] }
    );

    return createTypeDef({
      name: PropType.ENUM,
      caption: values.caption.join(' | '),
      value: values.value.join(' | '),
    });
  }

  return createTypeDef({ name: PropType.ENUM, caption: type.value });
}

function generateArray(type: Type, extractedProp: ExtractedProp): TypeDef {
  const braceAfter = (of: string) => `${of}[]`;
  const braceAround = (of: string) => `[${of}]`;

  // eslint-disable-next-line prefer-const
  let { name, caption, value, guessedType } = generateType(type.value, extractedProp);

  if (name === PropType.CUSTOM) {
    if (!isNil(guessedType)) {
      switch (guessedType) {
        case InspectionType.STRING:
          // Display the name of the object var if it's short.
          if (value.length <= MAX_CAPTION_LENGTH) {
            caption = value;
          }
          break;
        case InspectionType.OBJECT:
          // Brace around inlined objects.
          // Show the inlined object if it's short.
          caption =
            value.length <= MAX_CAPTION_LENGTH
              ? braceAround(value)
              : braceAfter(guessedType.toString());
          value = braceAround(value);

          return createTypeDef({ name: PropType.ARRAYOF, caption, value });
        default:
          caption = guessedType.toString();
      }
    }
  } else if (name === PropType.SHAPE) {
    // Brace around objects.
    caption = value.length <= MAX_CAPTION_LENGTH ? braceAround(value) : braceAfter(caption);
    value = braceAround(value);

    return createTypeDef({ name: PropType.ARRAYOF, caption, value });
  }

  return createTypeDef({ name: PropType.ARRAYOF, caption: braceAfter(value) });
}

function generateType(type: Type, extractedProp: ExtractedProp): TypeDef {
  try {
    switch (type.name) {
      case PropType.CUSTOM:
        return generateCustom(type);
      case PropType.FUNC:
        return generateFunc(extractedProp);
      case PropType.SHAPE:
        return generateShape(type, extractedProp);
      case PropType.INSTANCEOF:
        return createTypeDef({ name: PropType.INSTANCEOF, caption: type.value });
      case PropType.OBJECTOF:
        return generateObjectOf(type, extractedProp);
      case PropType.UNION:
        return generateUnion(type, extractedProp);
      case PropType.ENUM:
        return generateEnum(type);
      case PropType.ARRAYOF:
        return generateArray(type, extractedProp);
      default:
        return createTypeDef({ name: type.name, caption: type.name });
    }
  } catch (e) {
    // eslint-disable-next-line no-console
    console.error(e);
  }

  return createTypeDef({ name: 'unknown', caption: 'unknown' });
}

function renderType(type: Type, extractedProp: ExtractedProp): ReactNode {
  switch (type.name) {
    case PropType.CUSTOM:
    case PropType.SHAPE:
    case PropType.INSTANCEOF:
    case PropType.OBJECTOF:
    case PropType.UNION:
    case PropType.ENUM:
    case PropType.ARRAYOF: {
      const { caption, value } = generateType(type, extractedProp);

      return createPropText(caption, { title: caption !== value ? value : undefined });
    }
    case PropType.FUNC: {
      const { value } = generateType(type, extractedProp);

      return createPropText(value);
    }
    default:
      return null;
  }
}

export function enhancePropTypesProp(extractedProp: ExtractedProp): PropDef {
  const { propDef, docgenInfo } = extractedProp;

  const newtype = renderType(docgenInfo.type, extractedProp);

  if (!isNil(newtype)) {
    propDef.type = newtype;
  }

  return propDef;
}
